---
main_topsize: 0.2 #percent coverage of the poster
main_bottomsize: 0.01
title: '**Spatial Point Processes with INLA: are finer covariate resolutions always better?**'
author:
  - name: Sara Martino
    affil: 1
    main: true
  - name: Jafet Belmont
    affil: 2
    main: true
  - name: Erin Bryce
    affil: 2
    main: true
  - name: Leonardo Capitani 
    affil: 3
    main: true
  - name: Virginia Morera-Pujol
    affil: 4
    main: true
  - name: Megan Morton
    affil: 2
    main: true
  - name: Janine Illian 
    affil: 2
    main: true

affiliation:
  - num: 1
    address: Department of Mathematical Sciences, Norwegian University of Science and Technology
  - num: 2
    address: School of Mathematics and Statistics, University of Glasgow
  - num: 3
    address: Swiss Federal Institute for Forest, Snow and Landscape Research WSL, Birmensdorf, Switzerland
  - num: 4
    address: School of Biology and Environmental Science, University College Dublin

main_findings:
  - "The model only *sees* the covariate values at the integration points. Therefore, **the integration scheme and the covariates need to have similar resolution**"
  
output: 
  iheiddown::iheiddown_betterport:
    self_contained: false
    pandoc_args: --mathjax
    number_sections: false
bibliography: packages.bib
link-citations: true
editor_options: 
  markdown: 
    wrap: 72
  chunk_output_type: console
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      tidy = FALSE,
                      message = FALSE,
                      fig.align = 'center',
                      out.width = "100%")
options(knitr.table.format = "html") 
```

<!--# Author's order: I think we agreed Sara first and then alphabetical order and that's how's in the abstract so leaving it like that! -->

# Rationale

In ecology, spatial point processes (SPP) have become a popular
statistical tool, and INLA/SPDE an efficient method to implement 
them and make efficient inference. Central to this approach is the
representation of a spatially continuous Gaussian random field as the
solution of a stochastic partial differential equation (SPDE) defined
over a triangular mesh spanning the spatial domain. Although the mesh definition
is an important part of the model implementation. Equally crucial, yet
often overlooked, is the role of integration points employed in
numerically solving the stochastic integral inherent in the LGCP
likelihood.

<!-- Intro: I would love this to be a bit shorter and maybe a bit less technical, worth giving it some thought. Also need to make sure we convey the message that this is not SPDE/INLA's fault, and this intro is very inla/SPDE centric which I'm not sure conveys that. The word covariate is not even mentioned! The main message is that we need to chose covariates that act at a scale appropirate for the mesh/ipoints, not that the mesh and the ipoints can be thought of separately -->

# Main problem

When  using the INLA/SPDE implementation, the model only _sees_ the covariates at the integration points. Therefore, a covariate with a range much shorter than the distance between integration points will cause the model to provide unreliable inference. 

```{r, cropsfigure, fig.cap='In environmental variables with very short range like the one pictured below, the values change from 100 to 0 in very short distances. If the resolution of the integration points is not small enough to capture this short range, the model will struggle to infer the effect of the covariate, and the coefficients produced will be unreliable', out.width="90%"}

library(tidyterra)
library(ggplot2)
library(terra)

crops <- rast("ISEC_poster/crops.grd")
crops <- trim(crops)

ggplot() +
  geom_spatraster(data = crops) +
  scale_fill_whitebox_c(
    palette = "muted",
    labels = scales::label_number(suffix = "%"),
    n.breaks = 12,
    guide = guide_legend(reverse = TRUE)
  ) +
  
  labs(
    fill = "",
    title = "Planted vegetation and crops",
    subtitle = "Based on the CORINE 2016 data"
  ) + 
  theme_bw()
```

<!-- Main problem: I'd love to make this figure a bit bigger, like have the plot as wide as the column of text. Do you know how to do that?  -->

# An example

Let's picture three covariates with very different ranges: 

```{r, covars, fig.cap='Three covariates randomly generated. Covariate 1 has a range of 10, Covariate 2 has a range of 50, and covariate 3 has a range of 600', out.width="90%"}

library(ggplot2)
library(terra)
library(tidyterra)
library(scico)
library(patchwork)

cov1 <- rast("ISEC_poster/cov1.grd")
cov2 <- rast("ISEC_poster/cov2.grd")
cov3 <- rast("ISEC_poster/cov3.grd")

ggplot() + geom_spatraster(data = cov1) + 
  scale_fill_scico(na.value = "transparent") + 
  theme_bw() +
  theme(legend.position  = "none") +
  ggtitle("Covariate 1") + 
  coord_equal() +
  
  ggplot() + geom_spatraster(data = cov2) + 
  scale_fill_scico(na.value = "transparent") + 
  theme_bw() +
  theme(legend.position   = "none") +
  ggtitle("Covariate 2") + 
  coord_equal() +
  
  ggplot() + geom_spatraster(data = cov3) + 
  scale_fill_scico(na.value = "transparent") + 
  theme_bw() +
  theme(legend.position   = "none") +
  ggtitle("Covariate 3") + 
  coord_equal() +
  
  plot_layout(ncol = 2)

```

Now, let's fit a SPP model to those covariates with 6 slightly varying meshes. The only variation is that the domain of the mesh is slightly shifted in space for each of them. This will cause slightly shifted integration points for each, as these points are located at the vertices of the mesh triangles. 

```{r, meshes, fig.cap='This six meshes have been created with exaclty the same parameter, except that the iner boundary is shifted in space a little bit for each of them. That makes the integration points that are the vertices of the triangles shift a little too.', out.width="90%"}

library(tidyterra)
library(ggplot2)
library(terra)
library(inlabru)
library(scico)
library(patchwork)

meshes <- readRDS("ISEC_poster/random_meshes.RDS")
poly <- readRDS("ISEC_poster/random_poly.RDS")

ggplot() + gg(meshes[[1]]) +  geom_sf(data = poly, alpha = 0, color = "red") +
  coord_sf(xlim = c(-100,600), ylim = c(-100,600)) + ggtitle("Mesh 1") +
  xlab("") + ylab("")  + theme_void() + 
ggplot() + gg(meshes[[2]]) +  geom_sf(data = poly, alpha = 0, color = "red")+
  coord_sf(xlim = c(-100,600), ylim = c(-100,600))+ ggtitle("Mesh 2") +
  xlab("") + ylab("") + theme_void() +
ggplot() + gg(meshes[[3]]) +  geom_sf(data = poly, alpha = 0, color = "red")+
  coord_sf(xlim = c(-100,600), ylim = c(-100,600))+ ggtitle("Mesh 3") +
  xlab("") + ylab("") + theme_void() +
ggplot() + gg(meshes[[4]]) +  geom_sf(data = poly, alpha = 0, color = "red")+
  coord_sf(xlim = c(-100,600), ylim = c(-100,600))+ ggtitle("Mesh 4") +
  xlab("") + ylab("") + theme_void() +
ggplot() + gg(meshes[[5]]) +  geom_sf(data = poly, alpha = 0, color = "red")+
  coord_sf(xlim = c(-100,600), ylim = c(-100,600))+ ggtitle("Mesh 5") +
  xlab("") + ylab("") + theme_void() +
ggplot() + gg(meshes[[6]]) +  geom_sf(data = poly, alpha = 0, color = "red")+
  coord_sf(xlim = c(-100,600), ylim = c(-100,600))+ ggtitle("Mesh 6") +
  xlab("") + ylab("") + theme_void() 
```

After fitting one model with each mesh to the same point pattern, we can see how the coefficients vary much more for the covariate with the shortest range (Covariate 1), whereas the coefficients for the covariate with the longest range (Covariate 3) are much more stable 

```{r, coefficients, fig.cap='This six meshes have been created with exaclty the same parameter, except that the iner boundary is shifted in space a little bit for each of them. That makes the integration points that are the vertices of the triangles shift a little too.', out.width="90%"}

library(tidyterra)
library(ggplot2)
library(terra)
library(inlabru)
library(scico)
library(patchwork)

coefs <- readRDS("ISEC_poster/model_coefficients.RDS")

coefs %>% 
  filter(names=="cov") %>%
  mutate(cov = dplyr::case_match(cov, 
                          "Cov1" ~ "Covariate 1", 
                          "Cov2" ~ "Covariate 2", 
                          "Cov3" ~ "Covariate 3"), 
         int_points = dplyr::case_match(int_points, 
                                        "mesh 1" ~ 1,
                                        "mesh 2" ~ 2,
                                        "mesh 3" ~ 3,
                                        "mesh 4" ~ 4,
                                        "mesh 5" ~ 5,
                                        "mesh 6" ~ 6,)) %>% 
  ggplot() + geom_point(aes(x = mean, y = int_points)) +
  geom_segment(aes(y = int_points, yend  = int_points, x = `0.025quant`, xend = `0.975quant`)) +
  geom_vline(aes(xintercept = true), linetype = "dashed") + 
  scale_y_continuous(breaks = 1:6, labels = 1:6) +
  facet_grid(.~cov, scales = "free") +
  labs(y = "Mesh", x = "Mean covariate effect", title = "Covariate effect") + 
  theme_bw() + 
  coord_flip()

```

# A real world example

Here you may have some figures to show off, bellow I have made a
scatterplot with the infamous Iris dataset and I can even reference to
the figure automatically like this, `Figure \@ref(fig:irisfigure)`,
Figure \@ref(fig:irisfigure).


Maybe you want to show off some of that fancy code you spent so much
time on to make that figure, well you can do that too! Just use the
`echo=TRUE` option in the r code chunk options, Figure
\@ref(fig:myprettycode)!

```{r myprettycode, echo=TRUE, fig.cap='Boxplots, so hot right now!', fig.height=6, out.width="80%"}
#trim whitespace
par(mar=c(2,2,0,0))
#plot boxplots
boxplot(iris$Sepal.Width~iris$Species,
        col = "#ed2215", 
        border = "#800000",
        ylab = "Sepal Width (cm)",
        xlab = "Species")
```

How about a neat table of data? See, Table \@ref(tab:iristable):

```{r, iristable}
knitr::kable(
  iris[1:15,1:5], format = "html",
  caption = "A table made with the **knitr::kable** function.",
  align = "c", col.names = c("Sepal <br> Length",
                             "Sepal <br> Width",
                             "Petal <br> Length",
                             "Petal <br> Width",
                             "Species"),
  escape = FALSE)
```

# Conclusions

Using both simulations and real-world ecological data, we illustrate
these challenges and offer guidelines to empower users in navigating
these complexities and mitigating potential pitfalls when using these
methods in ecological applications such as species distribution models
based on presence-only data.

# References
